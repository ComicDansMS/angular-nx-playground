const fs = require('fs');
const path = require('path');
const CleanCSS = require('clean-css');
const yargs = require('yargs/yargs');
const { hideBin } = require('yargs/helpers');

const argv = yargs(hideBin(process.argv))
  .usage('Usage: $0 --stylesheet <css> --typescript <ts>')
  .option('stylesheet', {
    alias: 's',
    describe: 'Path to the CSS file to minify',
    type: 'string',
    demandOption: true,
  })
  .option('typescript', {
    alias: 't',
    describe: 'Path to the output TypeScript file',
    type: 'string',
    demandOption: true,
  })
  .help('h')
  .alias('h', 'help')
  .argv;

const cssFilePath = argv.stylesheet;
const styleTsPath = argv.typescript;

function processStyles() {
  try {
    const cssFile = fs.readFileSync(cssFilePath, 'utf8').trim();
    const cleanCSS = new CleanCSS({ compatibility: '*' });
    const minified = cleanCSS.minify(cssFile);

    if (minified.errors.length > 0) {
      console.error('CSS minification errors:', minified.errors);
      process.exit(1);
    }

    const newFileContents = `
/**
 * THIS FILE IS AUTOMATICALLY GENERATED
 * DO NOT EDIT DIRECTLY!
 *
 * Edit the original stylesheet at:
 * ${cssFilePath}
 */

export const style = \`${minified.styles}\`
    `;

    fs.writeFileSync(path.resolve(styleTsPath), newFileContents);
    console.log(
      `✅ CSS minified and injected: ${path.basename(cssFilePath)} → ${path.basename(
        styleTsPath
      )}`
    );
  } catch (error) {
    console.error('Error processing CSS:', error);
    process.exit(1);
  }
}

processStyles();
